<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=1024" />
<meta name="description" content="Learn data structures & algorithms interactively. Visualize sorting, searching, queues, stacks, and linked lists with real-time demonstrations." />
<meta name="keywords" content="data structures, algorithms, visualization, sorting, searching, queues, stacks, linked lists, bubble sort, binary search, learning tool" />
<meta name="author" content="Student Database Visualizer" />
<meta name="robots" content="index, follow" />
<meta property="og:title" content="Data Structures & Algorithms Visualizer" />
<meta property="og:description" content="Interactive visualization tool for learning data structures and algorithms with real-time demonstrations." />
<meta property="og:type" content="website" />
<link rel="canonical" href="https://warlord05.github.io/" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" type="image/svg+xml" href="/favicon.svg" />
<title>Data Structures & Algorithms Visualizer</title>
<!-- Deferred third-party scripts to prevent render blocking -->
<link rel="preconnect" href="https://pagead2.googlesyndication.com" />
<script defer src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5669546026348473"
     crossorigin="anonymous"></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "EducationalWebApplication",
  "name": "Data Structures & Algorithms Visualizer",
  "description": "Interactive visualization tool for learning data structures and algorithms with real-time demonstrations",
  "url": "https://warlord05.github.io/",
  "applicationCategory": "EducationalApplication",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "author": {
    "@type": "Person",
    "name": "Student Database Visualizer"
  },
  "learningResourceType": ["Interactive Tutorial", "Educational Tool"],
  "educationalLevel": "Intermediate",
  "keywords": "data structures, algorithms, visualization, sorting, searching, queues, stacks, linked lists"
}
</script>
<link rel="preload" href="/style.css" as="style" />
<link rel="stylesheet" href="/style.css" />
</head>
</head>
<body>
<main>
<div class="main-wrapper">
  <!-- Left Side Ad -->
  <div class="side-ad">
    <!-- Sidebar Left -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-5669546026348473"
         data-ad-slot="1767732028"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>

<div class="container">
  <h1>Data Structures & Algorithms Visualizer</h1>
  <p class="intro-text">
    Welcome to the <b>Data Structures & Algorithms Visualizer</b>, an interactive tool designed to help you understand fundamental concepts in computer science. This application lets you select different algorithms and data structures to see how they work in real-time. By visualizing key operations, you can gain a deeper and more intuitive understanding of complex processes like sorting, searching, and managing data in structures like stacks, queues, and linked lists.
  </p>

  <!-- Google Ad - Top Banner -->
  <div style="text-align: center; margin-bottom: 1.5em;">
    <!-- Top Banner -->
    <ins class="adsbygoogle"
         style="display:inline-block;width:728px;height:90px"
         data-ad-client="ca-pub-5669546026348473"
         data-ad-slot="4310134881"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>

  <h2>Select Algorithm or Data Structure</h2>
  <p>Below you can explore various fundamental algorithms and data structures used in computer science. Each visualization demonstrates how the algorithm works step-by-step, making it easier to understand the logic and complexity.</p>
  <div class="dropdown-container">
    <label for="algorithm-select">Choose an Algorithm or Data Structure:</label>
    <select id="algorithm-select">
      <optgroup label="Sorting & Searching">
        <option value="bubble">Bubble Sort</option>
        <option value="linear">Linear Search</option>
        <option value="binary">Binary Search</option>
      </optgroup>
      <optgroup label="Queues">
        <option value="linear-queue">Linear Queue</option>
        <option value="circular-queue">Circular Queue</option>
        <option value="deque">Deque</option>
        <option value="priority-queue">Priority Queue</option>
      </optgroup>
      <optgroup label="Linked Lists">
        <option value="sll">Singly Linked List</option>
        <option value="dll">Doubly Linked List</option>
        <option value="cll">Circular Linked List</option>
      </optgroup>
      <optgroup label="Stack">
        <option value="stack">Stack</option>
      </optgroup>
    </select>
  </div>

  <h2>Algorithm Implementation</h2>
  <div id="code-container">
    <pre id="cpp-code"></pre>
  </div>

  <h2>Interactive Visualization</h2>
  <div class="database" id="student-db"></div>

  <div class="controls" id="controls">
  </div>

  <h2>About Data Structures & Algorithms</h2>
  <p>Data structures and algorithms are fundamental concepts in computer science that form the foundation of efficient software development. Understanding these concepts is essential for writing better code, optimizing performance, and solving complex computational problems.</p>
  
  <h3>What You'll Learn</h3>
  <ul>
    <li><strong>Sorting Algorithms:</strong> Learn how different sorting techniques work, including Bubble Sort and its time complexity analysis.</li>
    <li><strong>Searching Algorithms:</strong> Understand Linear Search for sequential searching and Binary Search for optimized search on sorted data.</li>
    <li><strong>Queues:</strong> Explore Linear Queues, Circular Queues, Deques, and Priority Queues with their use cases and implementations.</li>
    <li><strong>Linked Lists:</strong> Master Singly Linked Lists, Doubly Linked Lists, and Circular Linked Lists for dynamic memory allocation.</li>
    <li><strong>Stacks:</strong> Learn about LIFO (Last In First Out) data structure and its applications in real-world programming.</li>
  </ul>

  <h3>Why Use This Visualizer?</h3>
  <p>Visual learning is proven to enhance understanding of complex concepts. This interactive visualizer allows you to:</p>
  <ul>
    <li>See real-time step-by-step execution of algorithms</li>
    <li>Understand how data moves and transforms during operations</li>
    <li>Learn the efficiency and time complexity of different approaches</li>
    <li>Practice with interactive demonstrations</li>
  </ul>

  <h3>Common Use Cases</h3>
  <p>Understanding these data structures and algorithms is crucial for:</p>
  <ul>
    <li>Technical interviews at top tech companies</li>
    <li>Optimizing application performance</li>
    <li>Solving competitive programming problems</li>
    <li>Building efficient backend systems</li>
    <li>Understanding database operations</li>
  </ul>

  <h3>Site Performance Monitoring</h3>
  <p>This site is deployed on Vercel with <strong>Speed Insights</strong> enabled to monitor real-time performance metrics. Learn more about how your experience is being optimized by visiting our <a href="/speed-insights-guide.html">Speed Insights Guide</a>.</p>
</div>

  <!-- Right Side Ad -->
  <div class="side-ad">
    <!-- Sidebar Right -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-5669546026348473"
         data-ad-slot="5623216557"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>
</div>
</main>

<script>
  const INITIAL_STUDENTS = [45, 23, 89, 12, 78, 56, 34];
  let students = [...INITIAL_STUDENTS];
  let sortedStudents = [...INITIAL_STUDENTS].sort((a, b) => a - b);
  const QUEUE_CAPACITY = 7;

  let linkedListState = [];
  let stackState = [];

  const codes = {
    bubble: `void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}`,
    linear: `int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key)
            return i;
    }
    return -1;
}`,
    binary: `int binarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == key)
            return mid;
        else if (arr[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}`,
    "linear-queue": `class LinearQueue {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    LinearQueue() {
        front = -1;
        rear = -1;
    }
    bool isEmpty() { return front == -1; }
    bool isFull() { return rear == MAX_SIZE - 1; }
    void enqueue(int x) {
        if (isFull()) return;
        if (isEmpty()) front = 0;
        rear++;
        arr[rear] = x;
    }
    int dequeue() {
        if (isEmpty()) return -1;
        int x = arr[front];
        if (front == rear) front = rear = -1;
        else front++;
        return x;
    }
};`,
    "circular-queue": `class CircularQueue {
private:
    int arr[MAX_SIZE];
    int front, rear;
    int size;
public:
    CircularQueue() {
        front = -1;
        rear = -1;
        size = 0;
    }
    bool isEmpty() { return size == 0; }
    bool isFull() { return size == MAX_SIZE; }
    void enqueue(int x) {
        if (isFull()) return;
        rear = (rear + 1) % MAX_SIZE;
        arr[rear] = x;
        if (front == -1) front = 0;
        size++;
    }
    int dequeue() {
        if (isEmpty()) return -1;
        int x = arr[front];
        front = (front + 1) % MAX_SIZE;
        size--;
        if (size == 0) front = rear = -1;
        return x;
    }
};`,
    "deque": `class Deque {
private:
    int arr[MAX_SIZE];
    int front, rear;
    int size;
public:
    Deque() {
        front = -1;
        rear = 0;
        size = 0;
    }
    bool isFull() { return size == MAX_SIZE; }
    bool isEmpty() { return size == 0; }
    void addFront(int key) {
        if (isFull()) return;
        if (isEmpty()) { front = 0; rear = 0; }
        else if (front == 0) front = MAX_SIZE - 1;
        else front--;
        arr[front] = key;
        size++;
    }
    void addRear(int key) {
        if (isFull()) return;
        if (isEmpty()) { front = 0; rear = 0; }
        else if (rear == MAX_SIZE - 1) rear = 0;
        else rear++;
        arr[rear] = key;
        size++;
    }
};`,
    "priority-queue": `class PriorityQueue {
private:
    vector<int> arr;
public:
    void enqueue(int x) {
        arr.push_back(x);
        sort(arr.begin(), arr.end());
    }
    int dequeue() {
        if (arr.empty()) return -1;
        int x = arr[0];
        arr.erase(arr.begin());
        return x;
    }
    int peek() {
        if (arr.empty()) return -1;
        return arr[0];
    }
};`,
    "sll": `struct Node {
    int data;
    Node* next;
};
class SinglyLinkedList {
public:
    Node* head;
    SinglyLinkedList() { head = nullptr; }
    void insertAtEnd(int data) {
        Node* newNode = new Node{data, nullptr};
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }
    void deleteFromBeginning() {
        if (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }
};`,
    "dll": `struct Node {
    int data;
    Node* next;
    Node* prev;
};
class DoublyLinkedList {
public:
    Node* head;
    DoublyLinkedList() { head = nullptr; }
    void insertAtFront(int data) {
        Node* newNode = new Node{data, head, nullptr};
        if (head != nullptr) {
            head->prev = newNode;
        }
        head = newNode;
    }
    void insertAtEnd(int data) {
        Node* newNode = new Node{data, nullptr, nullptr};
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
            newNode->prev = current;
        }
    }
};`,
    "cll": `struct Node {
    int data;
    Node* next;
};
class CircularLinkedList {
public:
    Node* head;
    CircularLinkedList() { head = nullptr; }
    void insertAtEnd(int data) {
        Node* newNode = new Node{data, nullptr};
        if (head == nullptr) {
            head = newNode;
            head->next = head;
        } else {
            Node* current = head;
            while (current->next != head) {
                current = current->next;
            }
            current->next = newNode;
            newNode->next = head;
        }
    }
    void deleteFromBeginning() {
        if (head == nullptr) return;
        if (head->next == head) {
            delete head;
            head = nullptr;
        } else {
            Node* last = head;
            while (last->next != head) {
                last = last->next;
            }
            Node* temp = head;
            head = head->next;
            last->next = head;
            delete temp;
        }
    }
};`,
    "stack": `class Stack {
private:
    std::vector<int> data;
public:
    bool isEmpty() {
        return data.empty();
    }
    void push(int value) {
        data.push_back(value);
    }
    void pop() {
        if (!data.empty()) {
            data.pop_back();
        }
    }
    int top() {
        if (data.empty()) {
            return -1;
        }
        return data.back();
    }
};`
  };

  // Get DOM elements with null checks
  const studentDbDiv = document.getElementById('student-db');
  const cppCodePre = document.getElementById('cpp-code');
  const controlsDiv = document.getElementById('controls');
  const algorithmSelect = document.getElementById('algorithm-select');
  
  // Verify all required elements exist
  if (!studentDbDiv || !cppCodePre || !controlsDiv || !algorithmSelect) {
    console.error('Required DOM elements not found');
  }

  let currentAlgo = 'bubble';

  let queueState = {
    arr: new Array(QUEUE_CAPACITY).fill(null),
    front: -1,
    rear: -1,
    size: 0,
    isEmpty: function() {
      return this.size === 0;
    },
    isFull: function() {
      return this.size === QUEUE_CAPACITY;
    }
  };

  function renderStudents(arr, highlightIndices = {}, foundIndex = -1, type = 'default') {
    studentDbDiv.innerHTML = '';
    studentDbDiv.classList.remove('stack-container');
    studentDbDiv.classList.add('database');
    
    arr.forEach((val, i) => {
      const wrapper = document.createElement('div');
      wrapper.classList.add('student-wrapper');
      
      const div = document.createElement('div');
      div.classList.add('student');
      if (val === null) {
        div.classList.add('empty');
        div.textContent = '';
      } else {
        div.textContent = val;
      }
      
      if (i === foundIndex) div.classList.add('found');
      if (highlightIndices.compared === i) div.classList.add('compared');
      if (highlightIndices.active === i) div.classList.add('active');

      if (type === 'linear-queue' || type === 'circular-queue' || type === 'deque' || type === 'priority-queue') {
        if (queueState.size > 0 && val !== null) {
          if (type === 'linear-queue' || type === 'circular-queue') {
            if (i === queueState.front && i === queueState.rear) {
              div.classList.add('front-rear-ptr');
            } else {
              if (i === queueState.front) div.classList.add('front-ptr');
              if (i === queueState.rear) div.classList.add('rear-ptr');
            }
          } else if (type === 'deque') {
            if (i === queueState.front) div.classList.add('deque-front');
            if (i === queueState.rear) div.classList.add('deque-rear');
          }
        }
      }

      const label = document.createElement('span');
      label.classList.add('student-label');
      if ((type === 'linear-queue' || type === 'circular-queue' || type === 'deque') && queueState.size > 0) {
        if (i === queueState.front && i === queueState.rear) {
          label.textContent = 'Front/Rear';
        } else if (i === queueState.front) {
          label.textContent = 'Front';
        } else if (i === queueState.rear) {
          label.textContent = 'Rear';
        } else {
          label.textContent = i;
        }
      } else {
        label.textContent = i;
      }
      wrapper.appendChild(label);
      wrapper.appendChild(div);
      studentDbDiv.appendChild(wrapper);
    });
  }

  function renderLinkedList(nodes, type) {
    studentDbDiv.innerHTML = '';
    studentDbDiv.classList.remove('database');
    studentDbDiv.classList.remove('stack-container');
    studentDbDiv.classList.add('linked-list-container');
    
    nodes.forEach((node, i) => {
      const nodeWrapper = document.createElement('div');
      nodeWrapper.classList.add('node-wrapper');

      const nodeDiv = document.createElement('div');
      nodeDiv.classList.add('node');
      
      const valueDiv = document.createElement('div');
      valueDiv.classList.add('node-value');
      valueDiv.textContent = node.value;
      
      nodeDiv.appendChild(valueDiv);

      if (type === 'dll') {
        const pointersDiv = document.createElement('div');
        pointersDiv.classList.add('node-pointers');
        pointersDiv.textContent = `prev | next`;
        nodeDiv.appendChild(pointersDiv);
      }
      
      nodeWrapper.appendChild(nodeDiv);
      
      if (i < nodes.length - 1) {
        if (type === 'sll' || type === 'cll') {
          const arrow = document.createElement('div');
          arrow.classList.add('arrow');
          arrow.innerHTML = '&#8594;';
          nodeWrapper.appendChild(arrow);
        } else if (type === 'dll') {
          const dllArrows = document.createElement('div');
          dllArrows.classList.add('dll-arrows');
          dllArrows.innerHTML = '&#8596;';
          nodeWrapper.appendChild(dllArrows);
        }
      }
      
      studentDbDiv.appendChild(nodeWrapper);
    });

    if (type === 'cll' && nodes.length > 0) {
      const lastNode = studentDbDiv.lastElementChild.querySelector('.node');
      const arrow = document.createElement('div');
      arrow.classList.add('cll-arrow');
      arrow.innerHTML = '&#8592;';
      studentDbDiv.appendChild(arrow);
    }
  }

  function renderStack(stack) {
    studentDbDiv.innerHTML = '';
    studentDbDiv.classList.remove('database');
    studentDbDiv.classList.remove('linked-list-container');
    studentDbDiv.classList.add('stack-container');
    
    stack.forEach((val, i) => {
      const wrapper = document.createElement('div');
      wrapper.classList.add('student-wrapper');
      
      const div = document.createElement('div');
      div.classList.add('student');
      div.textContent = val;

      if (i === stack.length - 1) {
          const label = document.createElement('span');
          label.classList.add('student-label');
          label.textContent = 'TOP';
          wrapper.appendChild(label);
      }
      
      wrapper.appendChild(div);
      studentDbDiv.appendChild(wrapper);
    });
  }

  function setActiveTab(algo) {
    const options = algorithmSelect.options;
    for (let i = 0; i < options.length; i++) {
        if (options[i].value === algo) {
            options[i].selected = true;
            break;
        }
    }
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function clearControls() {
    controlsDiv.innerHTML = '';
  }

  async function bubbleSortDemo() {
    let arr = [...INITIAL_STUDENTS];
    let n = arr.length;
    renderStudents(arr);
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - i - 1; j++) {
        renderStudents(arr, { compared: j, active: j + 1 });
        await sleep(400);
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          renderStudents(arr, { compared: j, active: j + 1 });
          await sleep(400);
        }
      }
    }
    renderStudents(arr);
  }

  async function linearSearchDemo(key) {
    let arr = [...INITIAL_STUDENTS];
    let n = arr.length;
    renderStudents(arr);
    for (let i = 0; i < n; i++) {
      renderStudents(arr, { active: i });
      await sleep(500);
      if (arr[i] === key) {
        renderStudents(arr, {}, i);
        alert('Student ID ' + key + ' found at index ' + i);
        return;
      }
    }
    alert('Student ID ' + key + ' not found');
    renderStudents(arr);
  }

  async function binarySearchDemo(key) {
    let arr = [...sortedStudents];
    let low = 0, high = arr.length - 1;
    renderStudents(arr);
    while (low <= high) {
      let mid = Math.floor(low + (high - low) / 2);
      renderStudents(arr, { active: mid });
      await sleep(600);
      if (arr[mid] === key) {
        renderStudents(arr, {}, mid);
        alert('Student ID ' + key + ' found at index ' + mid);
        return;
      } else if (arr[mid] < key) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    alert('Student ID ' + key + ' not found');
    renderStudents(arr);
  }

  async function linearQueueDemo() {
    const key = document.getElementById('queue-value').value;
    if (key === '') {
      alert('Please enter a value to enqueue.');
      return;
    }
    if (queueState.isFull()) {
      alert('Queue is full!');
      return;
    }
    
    const val = Number(key);
    if (queueState.isEmpty()) {
      queueState.front = 0;
    }
    queueState.rear++;
    queueState.arr[queueState.rear] = val;
    queueState.size++;
    
    renderStudents(queueState.arr, {}, -1, 'linear-queue');
  }

  async function linearQueueDequeue() {
    if (queueState.isEmpty()) {
      alert('Queue is empty!');
      return;
    }
    
    renderStudents(queueState.arr, { active: queueState.front }, -1, 'linear-queue');
    await sleep(800);
    
    const dequeuedVal = queueState.arr[queueState.front];
    queueState.arr[queueState.front] = null;
    
    if (queueState.front === queueState.rear) {
      queueState.front = -1;
      queueState.rear = -1;
    } else {
      queueState.front++;
    }
    
    queueState.size--;
    renderStudents(queueState.arr, {}, -1, 'linear-queue');
    alert('Dequeued value: ' + dequeuedVal);
  }

  async function circularQueueDemo() {
    const key = document.getElementById('queue-value').value;
    if (key === '') {
      alert('Please enter a value to enqueue.');
      return;
    }
    if (queueState.isFull()) {
      alert('Queue is full!');
      return;
    }
    
    const val = Number(key);
    if (queueState.isEmpty()) {
      queueState.front = 0;
      queueState.rear = 0;
    } else {
      queueState.rear = (queueState.rear + 1) % QUEUE_CAPACITY;
    }
    queueState.arr[queueState.rear] = val;
    queueState.size++;
    
    renderStudents(queueState.arr, {}, -1, 'circular-queue');
  }

  async function circularQueueDequeue() {
    if (queueState.isEmpty()) {
      alert('Queue is empty!');
      return;
    }
    
    renderStudents(queueState.arr, { active: queueState.front }, -1, 'circular-queue');
    await sleep(800);
    
    const dequeuedVal = queueState.arr[queueState.front];
    queueState.arr[queueState.front] = null;
    
    if (queueState.size === 1) {
      queueState.front = -1;
      queueState.rear = -1;
    } else {
      queueState.front = (queueState.front + 1) % QUEUE_CAPACITY;
    }
    
    queueState.size--;
    renderStudents(queueState.arr, {}, -1, 'circular-queue');
    alert('Dequeued value: ' + dequeuedVal);
  }

  async function dequeAddFront() {
    const key = document.getElementById('deque-value').value;
    if (key === '') {
      alert('Please enter a value.');
      return;
    }
    if (queueState.isFull()) {
      alert('Deque is full!');
      return;
    }
    
    renderStudents(queueState.arr, {}, -1, 'deque');
    await sleep(800);
    
    const val = Number(key);
    if (queueState.isEmpty()) {
      queueState.front = queueState.rear = 0;
    } else {
      queueState.front = (queueState.front - 1 + QUEUE_CAPACITY) % QUEUE_CAPACITY;
    }
    queueState.arr[queueState.front] = val;
    queueState.size++;
    renderStudents(queueState.arr, {}, -1, 'deque');
  }
  
  async function dequeAddRear() {
    const key = document.getElementById('deque-value').value;
    if (key === '') {
      alert('Please enter a value.');
      return;
    }
    if (queueState.isFull()) {
      alert('Deque is full!');
      return;
    }
    
    renderStudents(queueState.arr, {}, -1, 'deque');
    await sleep(800);
    
    const val = Number(key);
    if (queueState.isEmpty()) {
      queueState.front = queueState.rear = 0;
    } else {
      queueState.rear = (queueState.rear + 1) % QUEUE_CAPACITY;
    }
    queueState.arr[queueState.rear] = val;
    queueState.size++;
    renderStudents(queueState.arr, {}, -1, 'deque');
  }

  async function dequeRemoveFront() {
    if (queueState.isEmpty()) {
      alert('Deque is empty!');
      return;
    }
    renderStudents(queueState.arr, { active: queueState.front }, -1, 'deque');
    await sleep(800);
    
    const removedVal = queueState.arr[queueState.front];
    queueState.arr[queueState.front] = null;
    
    if (queueState.size === 1) {
      queueState.front = queueState.rear = -1;
    } else {
      queueState.front = (queueState.front + 1) % QUEUE_CAPACITY;
    }
    
    queueState.size--;
    renderStudents(queueState.arr, {}, -1, 'deque');
    alert('Removed from front: ' + removedVal);
  }

  async function dequeRemoveRear() {
    if (queueState.isEmpty()) {
      alert('Deque is empty!');
      return;
    }
    renderStudents(queueState.arr, { active: queueState.rear }, -1, 'deque');
    await sleep(800);
    
    const removedVal = queueState.arr[queueState.rear];
    queueState.arr[queueState.rear] = null;
    
    if (queueState.size === 1) {
      queueState.front = queueState.rear = -1;
    } else {
      queueState.rear = (queueState.rear - 1 + QUEUE_CAPACITY) % QUEUE_CAPACITY;
    }

    queueState.size--;
    renderStudents(queueState.arr, {}, -1, 'deque');
    alert('Removed from rear: ' + removedVal);
  }

  async function priorityQueueEnqueue() {
    const key = document.getElementById('priority-value').value;
    if (key === '') {
      alert('Please enter a value.');
      return;
    }
    const arr = queueState.arr.filter(val => val !== null);
    arr.push(Number(key));
    arr.sort((a, b) => a - b);
    
    queueState.arr = new Array(QUEUE_CAPACITY).fill(null);
    arr.forEach((val, i) => queueState.arr[i] = val);
    queueState.size = arr.length;
    
    renderStudents(queueState.arr, {}, -1, 'priority-queue');
  }

  async function priorityQueueDequeue() {
    if (queueState.isEmpty()) {
      alert('Priority Queue is empty!');
      return;
    }
    
    const arr = queueState.arr.filter(val => val !== null);
    const dequeuedVal = arr[0];
    
    renderStudents(queueState.arr, { active: 0 }, -1, 'priority-queue');
    await sleep(800);
    
    arr.shift();
    queueState.arr = new Array(QUEUE_CAPACITY).fill(null);
    arr.forEach((val, i) => queueState.arr[i] = val);
    queueState.size = arr.length;
    
    renderStudents(queueState.arr, {}, -1, 'priority-queue');
    alert('Dequeued value (highest priority): ' + dequeuedVal);
  }

  function sllInsert(val) {
    linkedListState.push({ value: val });
    renderLinkedList(linkedListState, 'sll');
  }

  function sllDelete() {
    if (linkedListState.length > 0) {
      linkedListState.shift();
      renderLinkedList(linkedListState, 'sll');
    } else {
      alert('List is empty!');
    }
  }

  function dllInsertFront(val) {
    linkedListState.unshift({ value: val });
    renderLinkedList(linkedListState, 'dll');
  }

  function dllInsertEnd(val) {
    linkedListState.push({ value: val });
    renderLinkedList(linkedListState, 'dll');
  }
  
  function dllDeleteFront() {
    if (linkedListState.length > 0) {
      linkedListState.shift();
      renderLinkedList(linkedListState, 'dll');
    } else {
      alert('List is empty!');
    }
  }
  
  function dllDeleteEnd() {
    if (linkedListState.length > 0) {
      linkedListState.pop();
      renderLinkedList(linkedListState, 'dll');
    } else {
      alert('List is empty!');
    }
  }

  function cllInsert(val) {
    linkedListState.push({ value: val });
    renderLinkedList(linkedListState, 'cll');
  }

  function cllDelete() {
    if (linkedListState.length > 0) {
      linkedListState.shift();
      renderLinkedList(linkedListState, 'cll');
    } else {
      alert('List is empty!');
    }
  }

  function stackPush() {
      const key = document.getElementById('stack-value').value;
      if (key === '') {
        alert('Please enter a value to push.');
        return;
      }
      stackState.push(Number(key));
      renderStack(stackState);
  }

  function stackPop() {
      if (stackState.length > 0) {
          const poppedVal = stackState.pop();
          renderStack(stackState);
          alert('Popped value: ' + poppedVal);
      } else {
          alert('Stack is empty!');
      }
  }

  function setupControls(algo) {
    clearControls();
    const createButton = (text, onClick) => {
      const btn = document.createElement('button');
      btn.textContent = text;
      btn.onclick = onClick;
      return btn;
    };
    const createInput = (id, placeholder) => {
      const input = document.createElement('input');
      input.type = 'number';
      input.min = '0';
      input.placeholder = placeholder;
      input.id = id;
      return input;
    };
    const createLabel = (text, input) => {
      const label = document.createElement('label');
      label.textContent = text;
      if (input) label.appendChild(input);
      return label;
    };

    if (algo === 'bubble') {
      controlsDiv.appendChild(createButton('Run Bubble Sort', bubbleSortDemo));
    } else if (algo === 'linear') {
      const input = createInput('search-key', 'e.g. 23');
      const label = createLabel('Enter Student ID: ', input);
      const btn = createButton('Run Linear Search', async () => {
        const key = Number(input.value);
        if (isNaN(key)) {
          alert('Please enter a valid number');
          return;
        }
        btn.disabled = true; input.disabled = true;
        await linearSearchDemo(key);
        btn.disabled = false; input.disabled = false;
      });
      controlsDiv.appendChild(label);
      controlsDiv.appendChild(btn);
    } else if (algo === 'binary') {
      const input = createInput('search-key', 'e.g. 23');
      const label = createLabel('Enter Student ID: ', input);
      const btn = createButton('Run Binary Search', async () => {
        const key = Number(input.value);
        if (isNaN(key)) {
          alert('Please enter a valid number');
          return;
        }
        btn.disabled = true; input.disabled = true;
        await binarySearchDemo(key);
        btn.disabled = false; input.disabled = false;
      });
      controlsDiv.appendChild(label);
      controlsDiv.appendChild(btn);
    } else if (algo === 'linear-queue') {
      controlsDiv.appendChild(createLabel('Enqueue Value:', createInput('queue-value', 'e.g. 10')));
      controlsDiv.appendChild(createButton('Enqueue', linearQueueDemo));
      controlsDiv.appendChild(createButton('Dequeue', linearQueueDequeue));
    } else if (algo === 'circular-queue') {
      controlsDiv.appendChild(createLabel('Enqueue Value:', createInput('queue-value', 'e.g. 10')));
      controlsDiv.appendChild(createButton('Enqueue', circularQueueDemo));
      controlsDiv.appendChild(createButton('Dequeue', circularQueueDequeue));
    } else if (algo === 'deque') {
      controlsDiv.appendChild(createLabel('Value:', createInput('deque-value', 'e.g. 10')));
      controlsDiv.appendChild(createButton('Add Front', dequeAddFront));
      controlsDiv.appendChild(createButton('Add Rear', dequeAddRear));
      controlsDiv.appendChild(createButton('Remove Front', dequeRemoveFront));
      controlsDiv.appendChild(createButton('Remove Rear', dequeRemoveRear));
    } else if (algo === 'priority-queue') {
      controlsDiv.appendChild(createLabel('Enqueue Value:', createInput('priority-value', 'e.g. 10')));
      controlsDiv.appendChild(createButton('Enqueue', priorityQueueEnqueue));
      controlsDiv.appendChild(createButton('Dequeue', priorityQueueDequeue));
    } else if (algo === 'sll') {
      const input = createInput('sll-value', 'e.g. 10');
      controlsDiv.appendChild(createLabel('Value:', input));
      controlsDiv.appendChild(createButton('Insert End', () => sllInsert(Number(input.value))));
      controlsDiv.appendChild(createButton('Delete Front', sllDelete));
    } else if (algo === 'dll') {
      const input = createInput('dll-value', 'e.g. 10');
      controlsDiv.appendChild(createLabel('Value:', input));
      controlsDiv.appendChild(createButton('Insert Front', () => dllInsertFront(Number(input.value))));
      controlsDiv.appendChild(createButton('Insert End', () => dllInsertEnd(Number(input.value))));
      controlsDiv.appendChild(createButton('Delete Front', dllDeleteFront));
      controlsDiv.appendChild(createButton('Delete End', dllDeleteEnd));
    } else if (algo === 'cll') {
      const input = createInput('cll-value', 'e.g. 10');
      controlsDiv.appendChild(createLabel('Value:', input));
      controlsDiv.appendChild(createButton('Insert End', () => cllInsert(Number(input.value))));
      controlsDiv.appendChild(createButton('Delete Front', cllDelete));
    } else if (algo === 'stack') {
      const input = createInput('stack-value', 'e.g. 10');
      controlsDiv.appendChild(createLabel('Value:', input));
      controlsDiv.appendChild(createButton('Push', stackPush));
      controlsDiv.appendChild(createButton('Pop', stackPop));
    }
  }

  function changeAlgorithm(algo) {
    currentAlgo = algo;
    setActiveTab(algo);
    cppCodePre.textContent = codes[algo];
    
    studentDbDiv.classList.remove('linked-list-container');
    studentDbDiv.classList.remove('stack-container');
    studentDbDiv.classList.add('database');

    if (algo === 'binary') {
      renderStudents(sortedStudents);
    } else if (algo.includes('queue') || algo.includes('deque')) {
      queueState.arr = new Array(QUEUE_CAPACITY).fill(null);
      queueState.front = -1;
      queueState.rear = -1;
      queueState.size = 0;
      renderStudents(queueState.arr, {}, -1, algo);
    } else if (algo === 'sll' || algo === 'dll' || algo === 'cll') {
      linkedListState = [];
      renderLinkedList(linkedListState, algo);
    } else if (algo === 'stack') {
      stackState = [];
      renderStack(stackState);
    } else {
      renderStudents(INITIAL_STUDENTS);
    }
    
    setupControls(algo);
  }

  algorithmSelect.addEventListener('change', (event) => {
    changeAlgorithm(event.target.value);
  });

  // Global error handler to prevent console errors from breaking functionality
  window.addEventListener('error', (event) => {
    console.warn('Runtime error caught:', event.error);
    // Prevent error from breaking the app
    event.preventDefault();
  });

  // Initialize the application with error handling
  try {
    changeAlgorithm('bubble');
  } catch (error) {
    console.error('Error initializing application:', error);
  }
</script>
<!-- Vercel Speed Insights -->
<script>
  window.si = window.si || function () { (window.siq = window.siq || []).push(arguments); };
</script>
<script defer src="/_vercel/speed-insights/script.js"></script>
</body>
</html>
